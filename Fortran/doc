
 大作业书面报告

完成人：肖飞宇（力4，2014011761）
2015年6月29日

一、	程序计划阶段的初步分析
程序定义：
本程序是利用Fortran语言的强大科学计算功能和Matlab语言丰富的库函数以及便利的图形界面的绘制功能，联合编程做出的GUI界面程序。
分形的绘制有其数学基础和丰富的前景，源自对于混沌这一数学系统的研究，已经有了很多不同的算法和解析方法，分形已经作为一种艺术，大量应用于图形美化等领域。
实质上这是一个数据的生成和图像表现的程序。
	程序可行性
	Fortran语言用于编写迭代等涉及大量浮点数运算的过程极其高效，而Matlab通过接口的配置可以方便的调用Fortran编写的计算程序,并完成数据的传递过程。
	在可视化方面，通过两种途径可以编写出GUI的程序界面，用图形界面来实现对于相应功能的实现。
	需求分析
Matlab有强大的功能，但在计算上还是逊色于Fortran；同时，Fortran有着优秀的科学计算的长处但是在图像的绘制上却很有短板。所以，将Fortran和Matlab实现联合编程，扬长避短，也是程序语言应用的一大方法和特色。
再者，随着力学等学科的进一步发展，孤子等非线性系统的研究的深入，有必要对于像分形这样的学科热点和前沿问题做一些初步的了解，通过编写程序，实质上也是一种自己的自觉或者不自觉的学习过程。

二、	程序设计思路
概要设计
	开发工具：VS Intel Fortran, Matlab 2014a
	模块设计：Fortran计算程序模块，Fortran和Matlab动态链接库接口模块，Matlab的GUI模块
	GUI的界面目标效果：简洁亲和
详细设计（附上代码进行注释说明，另外由于在这里进行了说明，对于源程序，我删去了很多注释）
代码分为两个部分，其一是迭代函数系统算法，其二是Mandelbrot集的逃逸时间算法。
一．	迭代函数系统算法
迭代函数系统算法是利用仿射变换结合概率分布而形成的算法，其核心是特定的IFS码，不同的图形有着共同的仿射变换的基本形式，但是不同的概率区间以及不同的变换系数将生成不同的图像。
基本算法步骤如下：
1.	生成随机数r，使得r的值在0到1之间。
2.	按照给定的参数生成各个仿射变换的概率空间。
3.	判断随机数落入哪一个空间，就进行相应的仿射变换。
4.	代换后在值点处画一个点。
5.	循环到满足一定循环次数。
下面以拼贴法生成的IFS树来做对于该算法的详细说明。
 

	subroutine ifs(figx,figy)
    !dll配置
    !DEC$ ATTRIBUTES C, DLLEXPORT::ifs
    !DEC$ ATTRIBUTES  REFERENCE::figx,figy
    !循环迭代次数
	integer,parameter:: pre=20000
    !随机变量
	real:: r(pre)
    
	integer i
    
	real(8) w1,w2,w3,w4         !仿射变换
	real(8) ww1,ww2,ww3,ww4     !仿射变换
    !IFS码
	real(8) a(4),b(4),c(4),d(4),e(4),f(4)
    !概率区间
	real(8):: p(4)
    
	real(8) :: m,n
    !值点的坐标
	real(8):: figx(pre),figy(pre)
    !迭代变量
	real(8):: x,y
	!暂时储存
	real(8):: xx,yy

    !语句函数
	w1(m,n)=a(1)*m+b(1)*n+e(1)
	ww1(m,n)=c(1)*m+d(1)*n+f(1)
	
	w2(m,n)=a(2)*m+b(2)*n+e(2)
	ww2(m,n)=c(2)*m+d(2)*n+f(2)

	w3(m,n)=a(3)*m+b(3)*n+e(3)
	ww3(m,n)=c(3)*m+d(3)*n+f(3)

	w4(m,n)=a(4)*m+b(4)*n+e(4)
	ww4(m,n)=c(4)*m+d(4)*n+f(4)

	x=0
	y=0



	!赋初值
    !生成随机变量
	call random_seed()
	do i=1,pre
	call random_number(r(i))
    end do
    
    !Tree所需要的特定的IFS值

	data a/-0.04,0.65,0.41,0.52/
	data b/0,0,0.46,-0.35/
	data c/-0.19,0,-0.39,0.25/
	data d/-0.47,0.56,0.61,0.74/
    data e/-0.12,0.06,0.46,-0.48/
	data f/0.3,1.56,0.4,0.38/
    
    !Tree所需要的特定概率区间分配
	
	p=0.25


    !循环迭代
    !在不同的概率区间执行不一样的对应的仿射变换
	do i=1,pre
		if(r(i)<0.25) then
		    xx=w1(x,y)
		    yy=ww1(x,y)
		else if(r(i)<0.50) then
		    xx=w2(x,y)
		    yy=ww2(x,y)
		else if(r(i)<0.75) then
		    xx=w3(x,y)
		    yy=ww3(x,y)
		else 
		    xx=w4(x,y)
		    yy=ww4(x,y)
	
		end if

		x=xx
		y=yy
		figx(i)=xx
		figy(i)=yy
		
	end do



	end subroutine

实际上，IFS算法如果在复平面上设计，即可以生成Julia集；更进一步讲，由于IFS码和概率区间即决定了图像的性质，如果设定特定的IFS码的变化甚至是连续变化，能够生成动态生长过程，或许可以体现一棵树的生长。

三、	Mandelbrot集的逃逸时间算法设计
选择一个初始的值，追踪其迭代点列，在参数空间里面记录点列的结构并绘图。


基本算法
	设定C的取值范围，即绘图窗口的上下界。假设绘图窗口的图像分辨率为a*b点，可显示颜色k+1种，用数字0到k表示，0表示黑色。
1.	选定逃逸半径M
按照像素在上下界之间均匀取点。
2.设定迭代的最高次数为k0，并且设定迭代方程。
3.对于每一个点完成以下的循环
计算现在的半径r和设定的逃逸半径比较
如果r>M，选择颜色K
如果k=k0,选择颜色0,
如果r小于或者等于M, 则进行迭代，并且k值加一。
4,。直到对于参数空间中每一点完成以上的操作。

下面是迭代阶数为2的M集生成的图像：
 

对应的代码算法如下：
subroutine mm(c,figx,figy)
    !DEC$ ATTRIBUTES C, DLLEXPORT::mm
    !DEC$ ATTRIBUTES  REFERENCE::c,figx,figy

    implicit none

    !迭代次数
	integer,parameter:: a=5000,b=5000
    
    !所求区域的上下界
	real:: pmin,pmax,qmin,qmax

    !收敛半径
	real*8:: d=500 
    !值点的间距
	real*8:: dx,dy

    !存储颜色值的数组
	real*8:: c(a+1,b+1)

    !值点数组
	real*8:: figx(a+1),figy(b+1)

    !迭代变量
	real*8:: x,y
    !临时储存的变量
	real*8:: xx,yy

    !逻辑变量做循环控制
	logical:: con=.false.

    !颜色变量
	integer*8 k  
    !迭代次数的上限
	integer*8,parameter:: k0=100
    !半径
    real*8 r

	!变化的序列
	real*8:: p,q

	integer*8 i,j
    
    
    !赋初值
	pmin=-2.3
	qmin=-1.2
	pmax=0.9
	qmax=1.2

	dx=(pmax-pmin)/a
	dy=(qmax-qmin)/b

	do i=1,a+1
        
		figx(i)=pmin+(i-1)*dx
		figy(i)=qmin+(i-1)*dy
    
    end do

	

   !循环迭代

	do i=1,a+1
        
		do j=1,b+1
            
		p=pmin+(i-1)*dx
		q=qmin+(j-1)*dy
        
        k=0
        x=0.0
        y=0.0
            
        con=.false.
        
			do while(con==.false.)
                xx=x*x-y*y+p
				yy=2*x*y+q
				k=k+1
                
                r=xx*xx+yy*yy
                
				x=xx
                y=yy

			
		
				if(r>d) then
			        c(i,j)=k
                    con=.true.
                else if(k==k0) then
                    c(i,j)=0
                    con=.true.
                else
                    cycle
                end if
                
               

			end do
		end do
	end do

	end subroutine

三．程序测试
测试方案：
由于这里涉及到两种语言的混合使用，这必然涉及到其各自的特点和接口所可能引起的问题，首先需要对于两种语言分别进行调试（由于matlab也有一些GUI的回调函数以及附加的一些功能的函数需要调试），再者需要对于混合后的兼容性进行调试和GUI的一些改进工作。
对于Fortran程序的调试，注意到首先是以函数存在的，所以我编写了一个调试的Program调用其进行测试，但是由于最后是生成了一些数组，所以我利用文件存取了数据，再直接在matlab中读入数据文件，绘图进行比对操作。

下面是导入数据的过程：
 


四、	心得体会
大作业的编写是一个完成一项完整任务的富有挑战性的过程，从信息的收集、筛选和整合以及加工，都是自主学习的过程。
特别是在刚刚学习完Fortran语言，有实质上需要自己学习一项新的语言的情况下，混合编程，制作GUI，需要一些从观念到习惯等的提升。
通过编程实践，我意识到，一项功能的实现可能需要很复杂的过程，但往往在对于程序设计语言和所面对的问题有一定的理解的情况下，或许使用合适的工具或者是算法的局部改进，会大大加快这一过程。
我也意识到，编写程序远远不是实现基本功能这样简单，其所涉及的方面很广泛，需要各个方面的能力的综合以及一个程序员的基本素养，又如在GUI的设计过程中，其布局、颜色等问题都是需要考虑的。
特别的，有两个小故事很有意思，写在这里作为总结。
我在写Mandelbrot集的时候，编写的Fortran程序和Matlab结合的时候，有一段时间总是数值发生变化，我连续花费了至少4个小时做程序的调试，最终发现是由于传递的变量中其变量的数据类型没有声明成双精度，这就导致了数据传递出现问题；这一问题关乎混合编程乃至编程实践中的实际问题的解决，很有启发意义。
再者，在调试图形颜色的过程中，似乎就如之前所讲的涉及了很多因素，这个过程很是有趣，我特地把其中一些图片附在下面（做了拼图效果）：
 
改进方面，觉得可以老师再多一些引导可能会好一点。
参考文献
1.分形算法程序设计-Visual C++ 实现  孙博文 科学出版社
2.Matlab GUI设计学习手记 罗华飞  北京航空航天大学出版社
3. Matlab与Fortran混合编程之 DLL实现方法 	潘克家,汤井田,郑洲顺
4. M-J集分形图形成算法及效果评价策略的研究  张桂兰 周大水 山东大学

	
附注：magnify.m文件下载自http://www.mathworks.com/matlabcentral/fileexchange/5961-magnify 是一个工具包，在GUI中我使用了这一函数，特别注明。
	

